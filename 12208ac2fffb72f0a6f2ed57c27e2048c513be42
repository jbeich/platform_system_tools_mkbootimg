{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "baf37a8f_4442c5fe",
        "filename": "mkbootimg.py",
        "patchSetId": 3
      },
      "lineNbr": 171,
      "author": {
        "id": 1337669
      },
      "writtenOn": "2021-03-09T11:17:57Z",
      "side": 1,
      "message": "I think this should be done in write_header_v3_and_above(), like how L117 is done",
      "range": {
        "startLine": 168,
        "startChar": 8,
        "endLine": 171,
        "endChar": 9
      },
      "revId": "12208ac2fffb72f0a6f2ed57c27e2048c513be42",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39b6e797_893db880",
        "filename": "mkbootimg.py",
        "patchSetId": 3
      },
      "lineNbr": 549,
      "author": {
        "id": 1337669
      },
      "writtenOn": "2021-03-09T11:17:57Z",
      "side": 1,
      "message": "Potential race?\n\ntemp file is opened by process mkbootimg, written to by process avbtool, and then read from process mkbootimg. I\u0027m worried that process mkbootimg might not get the changes made by process avbtool.\n\nI think the file should be open()-ed after avbtool has done writing it.",
      "range": {
        "startLine": 548,
        "startChar": 8,
        "endLine": 549,
        "endChar": 27
      },
      "revId": "12208ac2fffb72f0a6f2ed57c27e2048c513be42",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb8b186c_c836ed20",
        "filename": "mkbootimg.py",
        "patchSetId": 3
      },
      "lineNbr": 549,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2021-03-10T05:01:06Z",
      "side": 1,
      "message": "The check_call() will wait for the write process to complete (i.e., close()).\n\nAnd the read process also invokes seek(0) after that, that\u0027s why I think it should be ok.\n\nAnyway, we can open the file later. (it just adds more codes).",
      "parentUuid": "39b6e797_893db880",
      "range": {
        "startLine": 548,
        "startChar": 8,
        "endLine": 549,
        "endChar": 27
      },
      "revId": "12208ac2fffb72f0a6f2ed57c27e2048c513be42",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "81affd8f_7cbc9b4b",
        "filename": "mkbootimg.py",
        "patchSetId": 3
      },
      "lineNbr": 549,
      "author": {
        "id": 1337669
      },
      "writtenOn": "2021-03-10T05:16:38Z",
      "side": 1,
      "message": "ack,\nI agree your close() \u0026 seek() argument is sound.",
      "parentUuid": "fb8b186c_c836ed20",
      "range": {
        "startLine": 548,
        "startChar": 8,
        "endLine": 549,
        "endChar": 27
      },
      "revId": "12208ac2fffb72f0a6f2ed57c27e2048c513be42",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6daa347_6aaa80c9",
        "filename": "mkbootimg.py",
        "patchSetId": 3
      },
      "lineNbr": 563,
      "author": {
        "id": 1337669
      },
      "writtenOn": "2021-03-09T11:17:57Z",
      "side": 1,
      "message": "I think this is leaking implementation detail of add_boot_image_digest(). How about move this into add_boot_image_digest()?\n\nQQ, Should this be args.output.flush() \u0026\u0026 os.fsync(args.output.fileno())?",
      "range": {
        "startLine": 563,
        "startChar": 8,
        "endLine": 563,
        "endChar": 71
      },
      "revId": "12208ac2fffb72f0a6f2ed57c27e2048c513be42",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18189174_a1be4883",
        "filename": "mkbootimg.py",
        "patchSetId": 3
      },
      "lineNbr": 563,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2021-03-10T05:01:06Z",
      "side": 1,
      "message": "IIRC, flush() should be enough.\nNormally flush() is done in close().\n\nBut when we use close(), we don\u0027t need to fsync() later, right?",
      "parentUuid": "c6daa347_6aaa80c9",
      "range": {
        "startLine": 563,
        "startChar": 8,
        "endLine": 563,
        "endChar": 71
      },
      "revId": "12208ac2fffb72f0a6f2ed57c27e2048c513be42",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8739d64d_e35590a0",
        "filename": "mkbootimg.py",
        "patchSetId": 3
      },
      "lineNbr": 563,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2021-03-10T05:12:32Z",
      "side": 1,
      "message": "Nvm, let\u0027s still to fsync() to ensure the operating system buffers are synchronized with the storage devices (to be safe).",
      "parentUuid": "18189174_a1be4883",
      "range": {
        "startLine": 563,
        "startChar": 8,
        "endLine": 563,
        "endChar": 71
      },
      "revId": "12208ac2fffb72f0a6f2ed57c27e2048c513be42",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96535135_afdfc423",
        "filename": "mkbootimg.py",
        "patchSetId": 3
      },
      "lineNbr": 563,
      "author": {
        "id": 1337669
      },
      "writtenOn": "2021-03-10T05:16:38Z",
      "side": 1,
      "message": "I\u0027m honestly not sure. From what I know, flush() is a python thing, it flushes the buffered IO buffer of python. os.sync() is kernel thing, it ensures the data cached in memory is written back to disk.\n\nAnyway we could assume flush() then open() can read the previously flushed data, that is the kernel should take care of this?",
      "parentUuid": "18189174_a1be4883",
      "range": {
        "startLine": 563,
        "startChar": 8,
        "endLine": 563,
        "endChar": 71
      },
      "revId": "12208ac2fffb72f0a6f2ed57c27e2048c513be42",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74b05c75_5cce4bd0",
        "filename": "tests/mkbootimg_test.py",
        "patchSetId": 3
      },
      "lineNbr": 131,
      "author": {
        "id": 1337669
      },
      "writtenOn": "2021-03-09T11:17:57Z",
      "side": 1,
      "message": "I\u0027m confused...\nI thought we are appending the hash digest of boot.img, but seems like it\u0027s actually the vbmeta (which contains the hash dogest and other auxiliary data) of boot.img?\n\nIf we are indeed appending the vbmeta to boot.img, why not just call it \"boot image vbmeta\" (or \"boot image signature\") in the header bootimg.h? Calling it \"boot image digest\" when it is not a \"hash digest\" can confuse people, right?\n\nAnother questions is, it seems like the \"--gki_signing_extra_args\" argument can be arbitrarily long, so this mean the created vbmeta object can have variable length?\nShould we check this, that is, assert the size of vbmeta is always \u003c\u003d 4096?",
      "range": {
        "startLine": 131,
        "startChar": 51,
        "endLine": 131,
        "endChar": 61
      },
      "revId": "12208ac2fffb72f0a6f2ed57c27e2048c513be42",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1537f816_19515250",
        "filename": "tests/mkbootimg_test.py",
        "patchSetId": 3
      },
      "lineNbr": 131,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2021-03-10T05:01:06Z",
      "side": 1,
      "message": "\u003e why not just call it \"boot image vbmeta\" (or \"boot image signature\") in the header bootimg.h? \n\nMy concern is that \u0027boot image vbmeta\u0027 will confuse with the OEM\u0027s boot image vbmeta appended at the end of the boot.img. \n\n\u003e  Calling it \"boot image digest\" when it is not a \"hash digest\" can confuse people, right?\n\nThat\u0027s more like implementation details, where I\u0027d prefer not to disclose to avoid confusion with original boot.img vbmeta (appended to the end of the boot.img).\n\nActually we need a hash, but auxiliary data (e.g., signature, public key, etc) is required to ensure the hash is generated by an authorized owner. How about calling it \u0027GKI vbmeta\u0027? (but someone might thought we\u0027re building a boot.img here, whether it\u0027s a GKI or not is unknown...)\n\nAny more suggestions?\n\n\u003e assert the size of vbmeta is always \u003c\u003d 4096?\n\nGood suggestion, we can probably just assert the output vbmeta generated from avbtool is \u003c\u003d 4096 bytes.",
      "parentUuid": "74b05c75_5cce4bd0",
      "range": {
        "startLine": 131,
        "startChar": 51,
        "endLine": 131,
        "endChar": 61
      },
      "revId": "12208ac2fffb72f0a6f2ed57c27e2048c513be42",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}