{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "db9dafda_bc6ffccd",
        "filename": "Android.bp",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1337669
      },
      "writtenOn": "2023-10-05T06:27:56Z",
      "side": 1,
      "message": "can you move all these (Android.bp for rust, bindgen.sh, *.rs) into their own subdirectory (like ./rust or ./src/rust) just so we keep the different language files organized",
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a0e2f08_8cbc6e25",
        "filename": "Android.bp",
        "patchSetId": 6
      },
      "lineNbr": 33,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "For common configuration it can be useful to extract the shared stuff into a \"defaults\" target to reduce repetition and make sure targets stay in sync. Something like:\n\n```\nrust_defaults {\n    name: \"libbootimg_private_defaults\",\n    srcs: [\"src/bootimg_priv.rs\"],\n    rustlibs: [ \"libzerocopy\" ],\n    lints: \"none\",\n}\n\nrust_library{\n    name: \"libbootimg_private\",\n    crate_name: \"bootimg_private\",\n    defaults: [ \"libbootimg_private_defaults\" ],\n    vendor_available: true,\n    host_supported: true,\n    visibility: [\":__subpackages__\"]\n}\n\nrust_test_host {\n    name: \"libbootimg_tests_priv\",\n    auto_gen_config: true,\n    defaults: [ \"libbootimg_private_defaults\" ],\n}\n```\n\n(Same for `libbootimg`)",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 33,
        "endChar": 16
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b9c0848_10e1b5b1",
        "filename": "gindgen.sh",
        "patchSetId": 6
      },
      "lineNbr": 22,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "Is it possible to do some sort of quick and dirty \"golden\" file checking, e.g. maybe add some sort of build rule that runs this script and fails compilation if there are any diffs between the checked-in file and this output?\n\nMaybe the `genrule` Soong rule might be able to accomplish this? It looks like it allows for specifying an arbitrary `cmd` string. `sh_test_host` seems like another possibility, but ideally we would detect a mismatch and fail out during build rather than having to run a separate test.",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 22,
        "endChar": 53
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40176ef7_9001e508",
        "filename": "gindgen.sh",
        "patchSetId": 6
      },
      "lineNbr": 22,
      "author": {
        "id": 2029635
      },
      "writtenOn": "2023-10-05T18:11:00Z",
      "side": 1,
      "message": "I\u0027m not a big fan of golden file tests because they tend to be fragile, noisy, and often difficult to update. `genrule` looks promising, however; I\u0027m going to try to put something together that autogenerates `bootimg_priv.rs` and makes it visible to the wrapper library target.",
      "parentUuid": "3b9c0848_10e1b5b1",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 22,
        "endChar": 53
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2f0f262_6156c849",
        "filename": "gindgen.sh",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "nit: line length. Maybe put the args each on a newline with 4 indent? e.g.\n\n```\n./out/host/linux-x86/bin/bindgen \\\n    --blocklist-type\u003d\"${BLOCKED_TYPES_RE}\" \\\n    ...\n```",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 109
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f477351a_7ab5b457",
        "filename": "gindgen.sh",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 2029635
      },
      "writtenOn": "2023-10-05T18:11:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e2f0f262_6156c849",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 109
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5b90992_ee578d44",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "nit: the naming here feels a little inconsistent (`Foo` vs `FooHdr`) and sometimes redundant (`FooHdr::V3Hdr`). It also feels like while abbreviations like `hdr` are common in C code lately languages have been shifting towards just spelling out words especially in type names for readability.\n\nWDYT about something like:\n\n```\nenum BootImageHeader {\n  V0,\n  V1,\n  V2,\n  V3,\n  V4\n}\n\nenum VendorBootImageHeader {\n  V3,\n  V4\n}\n```\n\nIf that feels too long I think we could even just shorten it to `ImageHeader`/`VendorImageHeader` or even just `Header`/`VendorHeader`, though these names are general enough that it means users will be more likely to keep the library namespacing (e.g. `bootimg::Header` or `BootImageHeader` are nice and readable, just `ImageHeader` or `Header` less so)",
      "range": {
        "startLine": 27,
        "startChar": 9,
        "endLine": 27,
        "endChar": 16
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2823332b_c8bf3570",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 2029635
      },
      "writtenOn": "2023-10-05T18:11:00Z",
      "side": 1,
      "message": "That sounds reasonable, going with `ImageHeader` and `VendorImageHeader`.",
      "parentUuid": "f5b90992_ee578d44",
      "range": {
        "startLine": 27,
        "startChar": 9,
        "endLine": 27,
        "endChar": 16
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0049fd30_657327b0",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 51,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "nit: maybe `ImageError` here instead? `BootError` makes it sound like we attempted to boot and failed",
      "range": {
        "startLine": 51,
        "startChar": 9,
        "endLine": 51,
        "endChar": 18
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f79dece0_1f689c11",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 51,
      "author": {
        "id": 2029635
      },
      "writtenOn": "2023-10-05T18:11:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0049fd30_657327b0",
      "range": {
        "startLine": 51,
        "startChar": 9,
        "endLine": 51,
        "endChar": 18
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b54b0bf_e3ab846e",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "nit: just `Unknown` is probably fine here since it will be namespaced to `BootError::Unknown`",
      "range": {
        "startLine": 59,
        "startChar": 4,
        "endLine": 59,
        "endChar": 16
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f614aa1f_bcee4753",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 2029635
      },
      "writtenOn": "2023-10-05T18:11:00Z",
      "side": 1,
      "message": "Sounds good, I\u0027ll rename `UnknownVersion` to `UnexpectedVersion` to reduce collision.",
      "parentUuid": "7b54b0bf_e3ab846e",
      "range": {
        "startLine": 59,
        "startChar": 4,
        "endLine": 59,
        "endChar": 16
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c24324e0_367c0578",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 87,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "nit: I don\u0027t think we need newlines here, IIUC the Rustdoc parser will just ignore them though so if you think it\u0027s more readable it\u0027s fine to leave them.",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 87,
        "endChar": 7
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9c26957e_0da95302",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 87,
      "author": {
        "id": 2029635
      },
      "writtenOn": "2023-10-05T18:11:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c24324e0_367c0578",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 87,
        "endChar": 7
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e8c39ff1_bdb3cdc6",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 101,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "Rather than hardcoding offsets and manually parsing these fields, could we first attempt to interpret it as the smallest supported image type (I assume v0) and read these common fields directly, then re-interpret the buffer as the correct version?\n\n(Same below for vendor header)",
      "range": {
        "startLine": 101,
        "startChar": 8,
        "endLine": 101,
        "endChar": 79
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4ed5d8c_872fe729",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 101,
      "author": {
        "id": 2029635
      },
      "writtenOn": "2023-10-05T18:11:00Z",
      "side": 1,
      "message": "The `v3` header is actually the smallest, but it is explicitly designed so that the magic string and the header version are at the same offsets as `v0`.\nYeah, that sounds like a reasonable thing to try. I had hoped that `offsetof` would be usable so that raw sizes wouldn\u0027t be hardcoded, but double-parsing is the next best thing.",
      "parentUuid": "e8c39ff1_bdb3cdc6",
      "range": {
        "startLine": 101,
        "startChar": 8,
        "endLine": 101,
        "endChar": 79
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31b70a06_04a9d67d",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 101,
      "author": {
        "id": 2029635
      },
      "writtenOn": "2023-10-05T21:16:02Z",
      "side": 1,
      "message": "This is turning out to be tricky because `new_from_prefix` takes its parameter by value and consumes it. The return values of `new_from_prefix` are `(T, \u0026[u8])`, and even though _we_ know that they are adjacent it is not safe (and not even really a good idea with `unsafe`) to recombine `T.bytes()` with the suffix to make a single slice. I think that the hardcoded offsets are necessary.\n\nWe could get around this by trying to interpret as the *largest* supported type and then narrowing from there on the `bytes` method, but that doesn\u0027t feel great.",
      "parentUuid": "c4ed5d8c_872fe729",
      "range": {
        "startLine": 101,
        "startChar": 8,
        "endLine": 101,
        "endChar": 79
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32f2899a_439f7706",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 101,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T22:02:11Z",
      "side": 1,
      "message": "Huh interesting, maybe a lifetime scoping issue? It seems that if we return ownership back to `buffer` after the original split we should be able to re-split it again, e.g. from the Rust playground I can do this:\n\n```\nfn main() {\n    let mut data \u003d \u0026mut [1, 2, 3, 4, 5, 6];\n    \n    let (a, b) \u003d data.split_at_mut(3);\n    \n    // println!(\"data\u003d{:?}\", data);  // Doesn\u0027t compile since (a, b) still borrow `data`\n    println!(\"a\u003d{:?}, b\u003d{:?}\", a, b);\n    println!(\"data\u003d{:?}\", data);  // Works now, (a, b) have been returned\n    \n    // Now we can re-split at a different index.\n    let (a, b) \u003d data.split_at_mut(4);\n    println!(\"a\u003d{:?}, b\u003d{:?}\", a, b);\n}\n```\n\nBut perhaps zerocopy is doing something more complex with lifetimes than `split_at_mut()`, I\u0027ll keep poking around a bit.",
      "parentUuid": "31b70a06_04a9d67d",
      "range": {
        "startLine": 101,
        "startChar": 8,
        "endLine": 101,
        "endChar": 79
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "606c6cad_2515bab3",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 101,
      "author": {
        "id": 2029650
      },
      "writtenOn": "2023-10-05T22:20:33Z",
      "side": 1,
      "message": "I could be wrong but `new_from_prefix(buffer[..])` was working in this scenario.",
      "parentUuid": "32f2899a_439f7706",
      "range": {
        "startLine": 101,
        "startChar": 8,
        "endLine": 101,
        "endChar": 79
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "234c262a_0f997f8e",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 101,
      "author": {
        "id": 2029635
      },
      "writtenOn": "2023-10-05T22:21:30Z",
      "side": 1,
      "message": "So to confuse the issue even more, both builtin `slice` and `zerocopy::ByteSlice` define a `split_at_mut` method. The difference is that `slice` takes self by reference, and ByteSlice takes self by value. I don\u0027t think there\u0027s a way to return ownership unless the object explicitly returned by a function: that\u0027s the whole premise of references.\n\nTaking a step back, the C++-ish way to do this would be something like\n```\n// Ignoring alignment verification\nuint32_t version;\n{\n    const auto\u0026 tmp_hdr \u003d reinterpret_cast\u003cconst boot_img_hdr_v0\u0026\u003e(buffer);\n    if (tmp_hdr.magic !\u003d BOOT_MAGIC) { return Error(...); }\n    version \u003d tmp_hdr-\u003eversion;\n}\nswitch (version){\ncase 0: return ...;\ncase 1: return (buffer.size() \u003e\u003d sizeof(boot_img_hdr_v1) ? ... : Error(...));\ncase 2: return (buffer.size() \u003e\u003d sizeof(boot_img_hdr_v2) ? ... : Error(...));\n...\n}\n```\n\nIt\u0027s the aliasing and consuming by value that\u0027s preventing the same thing in Rust.\nMy guess is that there\u0027s an unsafe Rust way of making the aliasing work, but that\u0027s going to take some more experimentation. I\u0027ll keep trying, but if that winds up not working (or being very complicated) I think raw offsets is an increasingly attractive alternative.",
      "parentUuid": "32f2899a_439f7706",
      "range": {
        "startLine": 101,
        "startChar": 8,
        "endLine": 101,
        "endChar": 79
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}