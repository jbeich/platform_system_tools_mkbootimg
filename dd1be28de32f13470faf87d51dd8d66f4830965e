{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "db9dafda_bc6ffccd",
        "filename": "Android.bp",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1337669
      },
      "writtenOn": "2023-10-05T06:27:56Z",
      "side": 1,
      "message": "can you move all these (Android.bp for rust, bindgen.sh, *.rs) into their own subdirectory (like ./rust or ./src/rust) just so we keep the different language files organized",
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a0e2f08_8cbc6e25",
        "filename": "Android.bp",
        "patchSetId": 6
      },
      "lineNbr": 33,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "For common configuration it can be useful to extract the shared stuff into a \"defaults\" target to reduce repetition and make sure targets stay in sync. Something like:\n\n```\nrust_defaults {\n    name: \"libbootimg_private_defaults\",\n    srcs: [\"src/bootimg_priv.rs\"],\n    rustlibs: [ \"libzerocopy\" ],\n    lints: \"none\",\n}\n\nrust_library{\n    name: \"libbootimg_private\",\n    crate_name: \"bootimg_private\",\n    defaults: [ \"libbootimg_private_defaults\" ],\n    vendor_available: true,\n    host_supported: true,\n    visibility: [\":__subpackages__\"]\n}\n\nrust_test_host {\n    name: \"libbootimg_tests_priv\",\n    auto_gen_config: true,\n    defaults: [ \"libbootimg_private_defaults\" ],\n}\n```\n\n(Same for `libbootimg`)",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 33,
        "endChar": 16
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b9c0848_10e1b5b1",
        "filename": "gindgen.sh",
        "patchSetId": 6
      },
      "lineNbr": 22,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "Is it possible to do some sort of quick and dirty \"golden\" file checking, e.g. maybe add some sort of build rule that runs this script and fails compilation if there are any diffs between the checked-in file and this output?\n\nMaybe the `genrule` Soong rule might be able to accomplish this? It looks like it allows for specifying an arbitrary `cmd` string. `sh_test_host` seems like another possibility, but ideally we would detect a mismatch and fail out during build rather than having to run a separate test.",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 22,
        "endChar": 53
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2f0f262_6156c849",
        "filename": "gindgen.sh",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "nit: line length. Maybe put the args each on a newline with 4 indent? e.g.\n\n```\n./out/host/linux-x86/bin/bindgen \\\n    --blocklist-type\u003d\"${BLOCKED_TYPES_RE}\" \\\n    ...\n```",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 109
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5b90992_ee578d44",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "nit: the naming here feels a little inconsistent (`Foo` vs `FooHdr`) and sometimes redundant (`FooHdr::V3Hdr`). It also feels like while abbreviations like `hdr` are common in C code lately languages have been shifting towards just spelling out words especially in type names for readability.\n\nWDYT about something like:\n\n```\nenum BootImageHeader {\n  V0,\n  V1,\n  V2,\n  V3,\n  V4\n}\n\nenum VendorBootImageHeader {\n  V3,\n  V4\n}\n```\n\nIf that feels too long I think we could even just shorten it to `ImageHeader`/`VendorImageHeader` or even just `Header`/`VendorHeader`, though these names are general enough that it means users will be more likely to keep the library namespacing (e.g. `bootimg::Header` or `BootImageHeader` are nice and readable, just `ImageHeader` or `Header` less so)",
      "range": {
        "startLine": 27,
        "startChar": 9,
        "endLine": 27,
        "endChar": 16
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0049fd30_657327b0",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 51,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "nit: maybe `ImageError` here instead? `BootError` makes it sound like we attempted to boot and failed",
      "range": {
        "startLine": 51,
        "startChar": 9,
        "endLine": 51,
        "endChar": 18
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b54b0bf_e3ab846e",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "nit: just `Unknown` is probably fine here since it will be namespaced to `BootError::Unknown`",
      "range": {
        "startLine": 59,
        "startChar": 4,
        "endLine": 59,
        "endChar": 16
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c24324e0_367c0578",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 87,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "nit: I don\u0027t think we need newlines here, IIUC the Rustdoc parser will just ignore them though so if you think it\u0027s more readable it\u0027s fine to leave them.",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 87,
        "endChar": 7
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e8c39ff1_bdb3cdc6",
        "filename": "src/bootimg.rs",
        "patchSetId": 6
      },
      "lineNbr": 101,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2023-10-05T16:46:26Z",
      "side": 1,
      "message": "Rather than hardcoding offsets and manually parsing these fields, could we first attempt to interpret it as the smallest supported image type (I assume v0) and read these common fields directly, then re-interpret the buffer as the correct version?\n\n(Same below for vendor header)",
      "range": {
        "startLine": 101,
        "startChar": 8,
        "endLine": 101,
        "endChar": 79
      },
      "revId": "dd1be28de32f13470faf87d51dd8d66f4830965e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}